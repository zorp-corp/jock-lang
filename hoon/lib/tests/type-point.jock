/*  A class is broadly equivalent to a Hoon door. It has a top-level
    sample which represents its state, along with methods that have
    each their own samples.

    A class must be composed into the subject to be accessible.
*/
compose
  class Foo(x:@) {
    bar(p:@) -> Foo {
      p
    }
  }
; // end compose

//  let name:Type = value;
let a:Foo = Foo(42);
//  let name = Type(value);
let b = Foo(42);
//  let name:type = value;
let c:@ = 42;

(Foo(42) a b c)

/*
[p=[%call func=[%limb p=~[[%type p='Foo']]] arg=[~ [%atom p=[[%number p=42] q=%.n]]]]
 q=[p=[%limb p=~[[%name p=%a]]]
    q=[p=[%limb p=~[[%name p=%b]]]
       q=[%limb p=~[[%name p=%c]]]]]]

!=
=>  |_  x=@
    ++  load
      |=  p=@
      p
    --
(~(load . 10) 42)
[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [0 1] 9 2 10 [6 7 [0 3] 1 10] 0 2] 9 2 10 [6 7 [0 3] 1 42] 0 2]

.*  0
!=
=>  |_  x=@
    ++  load
      |=  p=@
      p
    --
=/  a  (load 10)
(~(bar . a) 42)
(~(load . a) 42)
[7 [8 [1 0] [1 8 [1 0] [1 4 0 6] 0 1] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 10] 0 2] 8 [8 [0 1] 9 2 10 [6 0 6] 0 5] 9 2 10 [6 7 [0 3] 1 42] 0 2]

::  this one best:
.*  0
!=
=/  a
  |_  x=@
  ++  load
    |=  p=@
    p
  --
(~(load a 5) 10)
[8 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [0 2] 9 2 10 [6 7 [0 3] 1 5] 0 2] 9 2 10 [6 7 [0 3] 1 10] 0 2]

[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [9 2 0 1]                         9 2 10 [6 7 [0 3] 1 42] 0 2] 0 2]

> `*`+:(~(mint ut %noun) %noun (ream '|_  x=@  ++  load  |=(p=@ p)  --'))
[8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1]

[7 [8 [1 0] [1 8 [1 0] [1 4 0 6] 0 1] 0 1] 8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2]
// [7 [8 [1 0] 1 8 [1 0] [1 4 0 6] 0 1] 8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2]

with [0 1], with Foo
[7 [8 [1 0] [1 8 [1 0] [1 4 0 6] 0 1] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 12]
with [0 1], without :Foo (works)
[7 [8 [1 0] [1 8 [1 0] [1 4 0 6] 0 1] 0 1] 8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2]
w/o [0 1], with Foo
[7 [8 [1 0] 1 8 [1 0] [1 4 0 6] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 12]
w/o [0 1], without :Foo
[7 [8 [1 0] 1 8 [1 0] [1 4 0 6] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 2]

!=  =>  |_  x=@
      ++  load
        |=  p=@
        p
      --
  (load 42)
[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2]

!=  =>  |_  x=@
      ++  load
        |=  p=@
        p
      --
  =/  a  (load 42)
  a

[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 2]
[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [9 1 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 3]

actual:
[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [9 1 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 3]

*/
