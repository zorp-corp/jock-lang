compose
  class Point(x:@ y:@) {
    add(p:(x:@ y:@)) -> Point {
      // we don't have infix operators yet so this is just a foobar
      (p.x p.y)
    }
    sub(p:(x:@ y:@)) -> Point {
      // we don't have infix operators yet so this is just a foobar
      (p.x p.x p.x)
    }
  }
; // end compose

/*
!=  =>  |_  x=@
      ++  load
        |=  p=@
        p
      --
=/  a  (load 42)
a
[7 [8 [1 0] [1 8 [1 0] [1 0 6] 0 1] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] 1 42] 0 2] 0 2]
*/
// works as of 2a2d5a82e66299a69cecb2196ea47b062cb73f4a
// [7 [8 [[1 0] 1 0] 1 [8 [[1 0] 1 0] [1 [0 12] 0 13] 0 1] 8 [1 0] [1 [7 [0 15] 0 7] 7 [0 15] 0 7] 0 1] 8 [9 2 0 1] 9 2 10 [6 7 [0 3] [1 70] 1 80] 0 2]
// Point(70 80)

// works as of 2a2d5a82e66299a69cecb2196ea47b062cb73f4a
// [7 [8 [[1 0] 1 0] 1 [8 [[1 0] 1 0] [1 [0 12] 0 13] 0 1] 8 [1 0] [1 [7 [0 15] 0 7] 7 [0 15] 0 7] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] [1 70] 1 80] 0 2] 0 2]
// let vector = Point(70 80);
// vector

// works as of 2a2d5a82e66299a69cecb2196ea47b062cb73f4a
// [7 [8 [[1 0] 1 0] 1 [8 [[1 0] 1 0] [1 [0 12] 0 13] 0 1] 8 [1 0] [1 [7 [0 15] 0 7] 7 [0 15] 0 7] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] [1 50] 1 60] 0 2] 0 3]
// let origin:Point = Point(50 60);
// origin

// fails
// [7 [8 [[1 0] 1 0] 1 [8 [[1 0] 1 0] [1 [0 12] 0 13] 0 1] 8 [1 0] [1 [7 [0 15] 0 7] 7 [0 15] 0 7] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] [1 50] 1 60] 0 2] 8 [0 3] 9 2 10 [6 7 [0 3] [1 70] 1 80] 0 2]
// [7 [8 [[1 0] 1 0] 1 [8 [[1 0] 1 0] [1 [0 12] 0 13] 0 1] 8 [1 0] [1 [7 [0 15] 0 7] 7 [0 15] 0 7] 0 1] 8 [8 [9 2 0 1] 9 2 10 [6 7 [0 3] [1 50] 1 60] 0 2] 8 [0 22] 9 2 10 [6 7 [0 3] [1 70] 1 80] 0 2]
let origin = Point(50 60);
// origin.add(Point(70 80))
(origin.add(70 80) origin.sub(90 100))

// fails (probably should)
// Point(50 60).add(70 80)
